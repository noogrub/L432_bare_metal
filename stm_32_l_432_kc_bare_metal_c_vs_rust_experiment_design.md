# Bare-Metal Memory Footprint Experiment

**Target:** STM32L432KC (NUCLEO‑L432KC, Nucleo‑32)

**Purpose:**
Establish a reproducible, bare‑metal comparison of **C vs Rust** on a real edge device by measuring flash and RAM usage as functionality is added incrementally. The goal is to map language/runtime cost directly onto the physical memory model of the MCU, without OS, HAL, or framework abstraction.

This document is intended to be sufficient for **independent reproduction** by another engineer.

---

## 1. Hardware

- **Board:** STM32 Nucleo‑32, NUCLEO‑L432KC
- **MCU:** STM32L432KCU6 (Cortex‑M4F)
- **On‑board debugger:** ST‑LINK/V2‑1 (SWD)
- **Power:** USB via ST‑LINK
- **User LED:** LD3 (Green)
  - Connected to **PB3** (Arduino Nano D13)
  - LED ON when PB3 = HIGH

---

## 2. Bare‑Metal Definition (Explicit)

For this experiment, *bare metal* means:

- No operating system
- No scheduler
- No syscalls
- No HAL or Cube libraries
- No autogenerated framework code

The firmware consists only of:
- Vector table
- Reset handler / startup
- Explicit peripheral register access
- Application code

> The program *is* the operating system.

---

## 3. Toolchain (Frozen for Reproducibility)

### C Toolchain
- `arm-none-eabi-gcc`
- `arm-none-eabi-ld`
- `arm-none-eabi-size`
- `arm-none-eabi-objdump`

### Rust Toolchain
- `rustc` (stable)
- `cargo`
- Target: `thumbv7em-none-eabi`
- `#![no_std]`
- `panic = abort`

### Flashing & Debug
- `stlink-tools`
  - `st-info`
  - `st-flash`
  - (optional) `st-util`

No IDEs are required. IDEs may be used **only** to extract reference linker scripts or startup files if needed, but must not contribute runtime code.

---

## 4. Flashing Method

Firmware is programmed using **ST‑LINK over SWD**:

- Flash base address: `0x08000000`
- Programming command (example):
  ```bash
  st-flash write firmware.bin 0x08000000
  ```

Mass‑storage drag‑and‑drop flashing is **not used** for this experiment.

---

## 5. Measurement Artifacts

For **every build** (C and Rust), preserve:

- `firmware.elf`
- `firmware.map`
- `size` output

### Recorded Metrics

| Metric | Meaning |
|------|--------|
| `.text` | Executable code in flash |
| `.rodata` | Constant data in flash |
| `.data` | Initialized RAM (copied from flash at boot) |
| `.bss` | Zero‑initialized RAM |
| **Total Flash** | `.text + .rodata + .data + vector table` |
| **Total RAM** | `.data + .bss + stack (+ heap if enabled)` |

No runtime code is added to compute metrics.

---

## 6. Experimental Stages

Each stage adds **exactly one new concept**.

### Stage 0 — Minimum Viable Firmware

**Purpose:** Establish language/runtime baseline

- Vector table
- Reset handler
- GPIO clock enable
- PB3 configured as output
- Busy‑wait delay loop
- Toggle LED indefinitely

No interrupts, no timers, no peripherals beyond GPIO.

---

### Stage 1 — Flash‑Resident Constant Data

**Purpose:** Measure `.rodata` behavior

- Add fixed lookup table (e.g. `const uint16_t table[128]`)
- Table is read but not modified

---

### Stage 2 — RAM‑Resident Ring Buffer

**Purpose:** Measure `.bss` growth

- Static ring buffer (e.g. `uint16_t ring[256]`)
- Updated in main loop

---

### Stage 3 — Timer Interrupt

**Purpose:** Introduce ISR + NVIC

- Configure a hardware timer
- Periodic interrupt (e.g. 100 Hz)
- ISR updates a counter

---

### Stage 4 — Volatile Register Read (Fake ADC)

**Purpose:** Test volatile semantics without ADC complexity

- Read from a volatile memory‑mapped location
- Value consumed but not transmitted

---

### Stage 5 — Real ADC + Internal Temperature Sensor

**Purpose:** Full peripheral bring‑up

- Enable ADC
- Read internal temperature sensor
- Use factory calibration constants

---

## 7. Results Table Template

```
Comparison Table — STM32L432KC
C vs Rust (Bare Metal)

Code Stage              | .text | .rodata | .data | .bss | Total Flash | Total RAM
----------------------------------------------------------------------------------
Stage 0: Base firmware  |       |         |       |      |             |
Stage 1: + rodata       |       |         |       |      |             |
Stage 2: + ring buffer  |       |         |       |      |             |
Stage 3: + ISR          |       |         |       |      |             |
Stage 4: + fake ADC     |       |         |       |      |             |
Stage 5: + real ADC     |       |         |       |      |             |
```

---

## 8. Design Philosophy

- Favor explicitness over convenience
- Favor reproducibility over speed
- Prefer clarity of causation to abstraction
- Treat memory as a physical resource, not a compiler statistic

This experiment is intended to answer *why* memory usage differs — not merely *that* it does.

---

**Status:** Design frozen. Ready to implement Stage 0.

